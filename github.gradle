if (!project.util) {
    apply from: 'util.gradle', to: project
}

println "Configuring $name's GitHub manager..."

buildscript {
    repositories {
        mavenCentral()
    }


    dependencies {
        classpath 'com.jcabi:jcabi-github:0.9.1'
    }
}

import com.jcabi.github.*
import com.jcabi.github.wire.CarefulWire
import com.jcabi.http.wire.*
import javax.ws.rs.core.HttpHeaders
import org.codehaus.groovy.runtime.EncodingGroovyMethods

ext.createGithub = { oauth, user, pass ->
    def rt = null
    def method = 0 // 0 = none, 1 = user/pass, 2 = oauth
    if (oauth == "" || oauth == null) {
        if (user == "" || user == null) {
            rt = new RtGithub()
            method = 0
        } else {
            rt = new RtGithub(user, pass)
            method = 1
        }
    } else {
        rt = new RtGithub(oauth)
        method = 2
    }
    def rt_req = rt.entry().through(RetryWire.class).through(CarefulWire.class, 50)

    ext.githubAuthMethod = method

    return new RtGithub(rt_req)
}

ext.getLastRelSmart = { releases ->
    def lastll = releases?.iterate()?.iterator()?.toList()
    def last = null
    if (lastll?.size() != 0) {
        last = lastll.last()
    }
    return last == null ? null : new Release.Smart(last)
}

import java.util.regex.Matcher
import java.util.regex.Pattern

// note: the following requires a tag version formatted as follows:
// "v$major.$minor.$patch"
// ('v' + major + '.' + minor + '.' + patch)
// and a project version formatted as follows:
// "$major.$minor.$patch"
// (major + '.' + minor + '.' + patch)

ext.versionNext = { relsm ->
    def pver = project.version
    def mat = pver =~ /(\d)\.(\d)\.(\d).*/
    if (!mat) {
        throw new IllegalArgumentException("project version ($pver) in wrong format")
    }

    print "Comparing $pver..."

    def pmajor = mat.group(1)
    def pminor = mat.group(2)
    def ppatch = mat.group(3)

    def lver = relsm?.tag()
    if (lver) {
        print "to $lver..."
    }
    println ""
    mat = lver =~ /v(\d)\.(\d)\.(\d)/
    if (mat) {
        def major = mat.group(1)
        def minor = mat.group(2)
        def patch = mat.group(3)
        if (pmajor > major + 1) {
            throw new RuntimeException("Too large of a jump: $major -> $pmajor")
        }
        if (pminor > minor + 1) {
            throw new RuntimeException("Too large of a jump: $minor -> $pminor")
        }
        if (ppatch > patch + 1) {
            throw new RuntimeException("Too large of a jump: $patch -> $ppatch")
        }
        println "Going from $lver -> $pver"
    } else {
        // assume version is right
        println "Assuming version v$pver is correct!"
    }
    return pver
}

task setupGithub() << {
    def _ = project.ext
    _.projCoord = new Coordinates.Simple("kenzierocks", "sample-command-tokenizer")
    _.git = project.createGithub(
        project._property("oauth"),
        project._property("user"),
        project._property("password")
    )
    _.proj = git.repos().get(projCoord)
}

task release(dependsOn: ['setupGithub', 'doBuild']) << {
    if (project.githubAuthMethod == 0) {
        // no auth, no upload!
        throw new RuntimeException("No authorization for upload!")
    }
    def releases = project.proj.releases()
    def rs = project.getLastRelSmart(releases)
    def ver = project.versionNext(rs)
    
    if ("v$ver" == rs?.tag()) {
        println "Version unchanged."
        return
    }

    def nrs = new Release.Smart(releases.create("v$ver"))
    if (_hasProperty("prerelease")) {
        nrs.prerelease(_property("prerelease").toBoolean())
    }
    if (_hasProperty("name")) {
        nrs.name(_property("name"))
    }

    def bytes = project.createAssetBytes()

    def name = _property("name")

    if (name == "" || name == null) {
        name = "sample-command-tokenizer-all-" + nrs.tag()
    }

    nrs.assets().upload(bytes, "application/java-archive", "$name.jar")
}

import com.jcabi.http.response.JsonResponse;
import com.jcabi.http.response.RestResponse;
import java.net.HttpURLConnection;

task clearRelease(dependsOn: 'setupGithub') << {
    def releases = project.proj.releases()

    def rem = null

    if (_hasProperty("remove")) {
        def ver = _property("remove")
        def itr = releases.iterate()
        for (item in itr) {
            def rsm = new Release.Smart(item)
            if (rsm.tag() == ver || (rsm.hasName() && rsm.name() == ver)) {
                rem = rsm
                break
            }
        }
    } else {
        def last = project.getLastRelSmart(releases)
        if (!last) {
            println "No releases!"
            return
        }
        rem = last
    }
    if (rem) {
        def tag = rem.tag()
        def req = project.git.entry()
        def repo = project.proj
        def rgit = new RtGit(req, repo)
        def rtags = rgit.tags()
        def tagjson = req.uri().path("/repos").path(repo.coordinates().user())
            .path(repo.coordinates().repo()).path("/tags").back().fetch()
            .as(RestResponse.class)
            .assertStatus(HttpURLConnection.HTTP_OK)
            .as(JsonResponse.class)
            .json().readArray()
        for (xtag in tagjson) {
            def tagName = xtag.getString("name")
            if (tagName == tag) {
                req.method(com.jcabi.http.Request.DELETE)
                .uri().path("/repos").path(repo.coordinates().user())
                .path(repo.coordinates().repo()).path("/git/refs/tags/$tagName").back().fetch()
                .as(RestResponse.class)
                .assertStatus(HttpURLConnection.HTTP_NO_CONTENT);
            }
        }
        releases.remove(rem.number())
    }
}

ext.github = true
println "Complete."
